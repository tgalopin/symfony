<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Cache\Adapter;

use Psr\Cache\CacheItemInterface;
use Psr\Cache\CacheItemPoolInterface;
use Psr\Log\LoggerAwareInterface;
use Psr\Log\LoggerAwareTrait;
use Symfony\Component\Cache\CacheItem;
use Symfony\Component\Cache\Exception\InvalidArgumentException;

/**
 * Adapter building static PHP files that will be cached by OPCache.
 * This Adapter is in read-only if you use AdapterInterface methods.
 * You can use the method "store" to build the cache file.
 *
 * @author Titouan Galopin <galopintitouan@gmail.com>
 * @author Nicolas Grekas <p@tchwork.com>
 */
class OpCacheAdapter implements AdapterInterface, LoggerAwareInterface
{
    use LoggerAwareTrait;

    private $file;
    private $umask;
    private $values;
    private $createCacheItem;

    /** @var AdapterInterface */
    private $fallbackPool;

    /**
     * @param string $file The PHP file were values are cached.
     *
     * @return CacheItemPoolInterface
     */
    public static function createOnPhp7($file, CacheItemPoolInterface $fallbackPool)
    {
        // OPcache shared memory for arrays works only with PHP 7.0+
        if (PHP_VERSION_ID >= 70000) {
            if (!$fallbackPool instanceof AdapterInterface) {
                $fallbackPool = new ProxyAdapter($fallbackPool);
            }

            return new static($file, $fallbackPool);
        }

        return $fallbackPool;
    }

    /**
     * @param string           $file         The PHP file were values are cached.
     * @param AdapterInterface $fallbackPool A pool to fallback on when an item is not hit.
     * @param int              $umask
     *
     * @throws \InvalidArgumentException When the umask is invalid.
     */
    public function __construct($file, AdapterInterface $fallbackPool, $umask = 0002)
    {
        if (!is_int($umask)) {
            throw new \InvalidArgumentException(sprintf('The parameter umask must be an integer, was: %s', gettype($umask)));
        }

        $this->file = $file;
        $this->umask = $umask;
        $this->fallbackPool = $fallbackPool;
        $this->createCacheItem = \Closure::bind(
            function ($key, $value, $isHit) {
                $item = new CacheItem();
                $item->key = $key;
                $item->value = $value;
                $item->isHit = $isHit;

                return $item;
            },
            $this,
            CacheItem::class
        );
    }

    /**
     * Store a static array of cached values.
     *
     * @param array $values The cached values.
     */
    public function store(array $values)
    {
        if (file_exists($this->file)) {
            if (!is_file($this->file)) {
                throw new InvalidArgumentException(sprintf('Cache path exists and is not a file: %s', $this->file));
            }

            if (!is_writable($this->file)) {
                throw new InvalidArgumentException(sprintf('Cache file is not writable: %s', $this->file));
            }
        } else {
            $directory = dirname($this->file);

            if (!is_dir($directory) && !@mkdir($directory, 0777 & (~$this->umask), true)) {
                throw new InvalidArgumentException(sprintf('Cache directory does not exist and cannot be created: %s', $directory));
            }

            if (!is_writable($directory)) {
                throw new InvalidArgumentException(sprintf('Cache directory is not writable: %s', $directory));
            }
        }

        $dump = <<<EOF
<?php

// This file has been auto-generated by the Symfony Cache Component.

return array(


EOF;

        foreach ($values as $key => $value) {
            CacheItem::validateKey($key);

            if (null === $value || is_object($value)) {
                try {
                    $value = serialize($value);
                } catch (\Exception $e) {
                    throw new InvalidArgumentException(sprintf('Cache key "%s has non-serializable %s value', $key, get_class($value)), 0, $e);
                }
            } elseif (is_array($value)) {
                try {
                    $serialized = serialize($value);
                    $unserialized = unserialize($serialized);
                } catch (\Exception $e) {
                    throw new InvalidArgumentException(sprintf('Cache key "%s has non-serializable array value', $key), 0, $e);
                }
                // Store arrays serialized if they contain any objects or references
                if ($unserialized !== $value || (false !== strpos($serialized, ';R:') && preg_match('/;R:[1-9]/', $serialized))) {
                    $value = $serialized;
                }
            } elseif (is_string($value)) {
                // Serialize strings if they could be confused with serialized objects or arrays
                if ('N;' === $value || (isset($value[2]) && ':' === $value[1])) {
                    $value = serialize($value);
                }
            } elseif (!is_scalar($value)) {
                throw new InvalidArgumentException(sprintf('Cache key "%s has non-serializable %s value', $key, gettype($value)));
            }

            $dump .= var_export($key, true).' => '.var_export($value, true).",\n";
        }

        $dump .= "\n);\n";
        $dump = str_replace("' . \"\\0\" . '", "\0", $dump);

        $tmpFile = uniqid($this->file);

        file_put_contents($tmpFile, $dump);
        @chmod($tmpFile, 0666 & (~$this->umask));
        unset($serialized, $unserialized, $value, $dump);

        if ('\\' === DIRECTORY_SEPARATOR) {
            // Windows does not support overwrite during rename
            @unlink($this->file);
            @rename($tmpFile, $this->file);
        } else {
            rename($tmpFile, $this->file);
        }

        $this->values = (include $this->file) ?: array();
    }

    /**
     * {@inheritdoc}
     */
    public function getItem($key)
    {
        CacheItem::validateKey($key);

        if (null === $this->values) {
            $this->initialize();
        }

        if (!isset($this->values[$key])) {
            return $this->fallbackPool->getItem($key);
        }

        $value = $this->values[$key];

        if ('N;' === $value) {
            $value = null;
        } elseif (isset($value[2]) && is_string($value) && ':' === $value[1]) {
            $value = unserialize($value);
        }

        $f = $this->createCacheItem;

        return $f($key, $value, true);
    }

    /**
     * {@inheritdoc}
     */
    public function getItems(array $keys = array())
    {
        foreach ($keys as $key) {
            CacheItem::validateKey($key);
        }

        if (null === $this->values) {
            $this->initialize();
        }

        return $this->generateItems($keys);
    }

    /**
     * {@inheritdoc}
     */
    public function hasItem($key)
    {
        CacheItem::validateKey($key);

        if (null === $this->values) {
            $this->initialize();
        }

        return isset($this->values[$key]) || $this->fallbackPool->hasItem($key);
    }

    /**
     * {@inheritdoc}
     */
    public function clear()
    {
        if (null === $this->values) {
            $this->initialize();
        }

        return $this->fallbackPool->clear() && !$this->values;
    }

    /**
     * {@inheritdoc}
     */
    public function deleteItem($key)
    {
        CacheItem::validateKey($key);

        if (null === $this->values) {
            $this->initialize();
        }

        return !isset($this->values[$key]) && $this->fallbackPool->deleteItem($key);
    }

    /**
     * {@inheritdoc}
     */
    public function deleteItems(array $keys)
    {
        if (null === $this->values) {
            $this->initialize();
        }

        foreach ($keys as $key) {
            CacheItem::validateKey($key);
        }

        $deleted = true;
        $fallbackKeys = array();

        foreach ($keys as $key) {
            if (isset($this->values[$key])) {
                $deleted = false;
            } else {
                $fallbackKeys[] = $key;
            }
        }

        if ($fallbackKeys) {
            $deleted = $this->fallbackPool->deleteItems($fallbackKeys) && $deleted;
        }

        return $deleted;
    }

    /**
     * {@inheritdoc}
     */
    public function save(CacheItemInterface $item)
    {
        if (null === $this->values) {
            $this->initialize();
        }

        return !isset($this->values[$item->getKey()]) && $this->fallbackPool->save($item);
    }

    /**
     * {@inheritdoc}
     */
    public function saveDeferred(CacheItemInterface $item)
    {
        if (null === $this->values) {
            $this->initialize();
        }

        return !isset($this->values[$item->getKey()]) && $this->fallbackPool->saveDeferred($item);
    }

    /**
     * {@inheritdoc}
     */
    public function commit()
    {
        return $this->fallbackPool->commit();
    }

    /**
     * Load the cache file.
     */
    private function initialize()
    {
        $this->values = @(include $this->file) ?: array();
    }

    /**
     * Generator for items.
     *
     * @param array $keys
     *
     * @return \Generator
     */
    private function generateItems(array $keys)
    {
        $f = $this->createCacheItem;
        $fallbackKeys = array();

        foreach ($keys as $key) {
            if (isset($this->values[$key])) {
                $value = $this->values[$key];

                if ('N;' === $value) {
                    $value = null;
                } elseif (isset($value[2]) && is_string($value) && ':' === $value[1]) {
                    $value = unserialize($value);
                }

                yield $key => $f($key, $value, true);
            } else {
                $fallbackKeys[] = $key;
            }
        }

        if ($fallbackKeys) {
            foreach ($this->fallbackPool->getItems($fallbackKeys) as $key => $item) {
                yield $key => $item;
            }
        }
    }
}
